#pragma once

#include <mutex>
#include <memory>
#include <cstdint>

namespace HookTemplate {
	struct alignas(16) Context {
		using reg64 = int[2];
		using imm256 = float[8];
		reg64 rax;
		reg64 rbx;
		reg64 rcx;
		reg64 rdx;
		reg64 rsp;
		reg64 rbp;
		reg64 rsi;
		reg64 rdi;
		reg64 r8;
		reg64 r9;
		reg64 r10;
		reg64 r11;
		reg64 r12;
		reg64 r13;
		reg64 r14;
		reg64 r15;
		imm256 imm0;
		imm256 imm1;
		imm256 imm2;
		imm256 imm3;
		imm256 imm4;
		imm256 imm5;
		imm256 imm6;
		imm256 imm7;
		imm256 imm8;
		imm256 imm9;
		imm256 imm10;
		imm256 imm11;
		imm256 imm12;
		imm256 imm13;
		imm256 imm14;
		imm256 imm15;
	};

	struct HookData {
		HookData() {}

		const unsigned long long magic = 0x6B6F6F48696E55ull; // magic: "UniHook\0"
		uint64_t : 64;
		std::shared_ptr<std::mutex> mutex = nullptr;
		std::unique_ptr<Context> allocator = std::make_unique<Context>();
		Context* context = allocator.get();
		void* previous = nullptr;
		void* fnNew = nullptr;
		void* fnHooked = nullptr;
		void* extra = nullptr;
	};

	struct Base {
		Base() {}

		//data:
		HookData hookData{};

		// assembly:
		unsigned char asmRaw[114] = {
		0x48, 0x8D, 0x44, 0x24, 0xA0,       // lea    rax,[rsp-0x60]
		0x24, 0xF0,                   		// and    al,0xF0
		0x0F, 0x29, 0x40, 0x50,             // movaps [rax+0x50],xmm0
		0x0F, 0x29, 0x48, 0x40,             // movaps [rax+0x40],xmm1
		0x0F, 0x29, 0x50, 0x30,             // movaps [rax+0x30],xmm2
		0x0F, 0x29, 0x58, 0x20,             // movaps [rax+0x20],xmm3
		0x0F, 0x29, 0x60, 0x10,             // movaps [rax+0x10],xmm4
		0x0F, 0x29, 0x28,                	// movaps [rax],xmm5
		0x48, 0x89, 0x60, 0xF0,             // mov    [rax-0x10],rsp
		0x48, 0x89, 0x48, 0xE8,             // mov    [rax-0x18],rcx
		0x48, 0x89, 0x50, 0xE0,             // mov    [rax-0x20],rdx
		0x4C, 0x89, 0x40, 0xD8,             // mov    [rax-0x28],r8
		0x4C, 0x89, 0x48, 0xD0,             // mov    [rax-0x30],r9
		0x48, 0x8D, 0x60, 0xB0,             // lea    rsp,[rax-0x50]
		0xFF, 0x15, 0xAC, 0xFF, 0xFF, 0xFF, // call   [fnNew]
		0x48, 0x8D, 0x44, 0x24, 0x50,       // lea    rax,[rsp+0x50]
		0x4C, 0x8B, 0x48, 0xD0,             // mov    r9,[rax-0x30]
		0x4C, 0x8B, 0x40, 0xD8,             // mov    r8,[rax-0x28]
		0x48, 0x8B, 0x50, 0xE0,             // mov    rdx,[rax-0x20]
		0x48, 0x8B, 0x48, 0xE8,             // mov    rcx,[rax-0x18]
		0x0F, 0x28, 0x28,                	// movaps xmm5,[rax]
		0x0F, 0x28, 0x60, 0x10,             // movaps xmm4,[rax+0x10]
		0x0F, 0x28, 0x58, 0x20,             // movaps xmm3,[rax+0x20]
		0x0F, 0x28, 0x50, 0x30,             // movaps xmm2,[rax+0x30]
		0x0F, 0x28, 0x48, 0x40,             // movaps xmm1,[rax+0x40]
		0x0F, 0x28, 0x40, 0x50,             // movaps xmm0,[rax+0x50]
		0x48, 0x8B, 0x60, 0xF0,             // mov    rsp,[rax-0x10]
		0xFF, 0x25, 0x7E, 0xFF, 0xFF, 0xFF, // jmp    [fnHooked]
		};
	};

	struct Return {
		Return() {}

		//data:
		HookData hookData{};

		// assembly:
		unsigned char asmRaw[125] = {
		0x51,								// push   rcx
		0x48, 0x83, 0xEC, 0x20,				// sub    rsp,20
		0xFF, 0x15, 0xE5, 0xFF, 0xFF, 0xFF,	// call   [fnHooked]
		0x48, 0x83, 0xC4, 0x20,				// sub    add,20
		0x59,								// pop    rcx
		0x48, 0x8D, 0x44, 0x24, 0xA0,		// lea    rax,[rsp-0x60]
		0x24, 0xF0,                   		// and    al,0xF0
		0x0F, 0x29, 0x40, 0x50,             // movaps [rax+0x50],xmm0
		0x0F, 0x29, 0x48, 0x40,             // movaps [rax+0x40],xmm1
		0x0F, 0x29, 0x50, 0x30,             // movaps [rax+0x30],xmm2
		0x0F, 0x29, 0x58, 0x20,             // movaps [rax+0x20],xmm3
		0x0F, 0x29, 0x60, 0x10,             // movaps [rax+0x10],xmm4
		0x0F, 0x29, 0x28,                	// movaps [rax],xmm5
		0x48, 0x89, 0x60, 0xF0,             // mov    [rax-0x10],rsp
		0x48, 0x89, 0x48, 0xE8,             // mov    [rax-0x18],rcx
		0x48, 0x89, 0x50, 0xE0,             // mov    [rax-0x20],rdx
		0x4C, 0x89, 0x40, 0xD8,             // mov    [rax-0x28],r8
		0x4C, 0x89, 0x48, 0xD0,             // mov    [rax-0x30],r9
		0x48, 0x8D, 0x60, 0xB0,             // lea    rsp,[rax-0x50]
		0xFF, 0x15, 0x9C, 0xFF, 0xFF, 0xFF, // call   [fnNew]
		0x48, 0x8D, 0x44, 0x24, 0x50,       // lea    rax,[rsp+0x50]
		0x4C, 0x8B, 0x48, 0xD0,             // mov    r9,[rax-0x30]
		0x4C, 0x8B, 0x40, 0xD8,             // mov    r8,[rax-0x28]
		0x48, 0x8B, 0x50, 0xE0,             // mov    rdx,[rax-0x20]
		0x48, 0x8B, 0x48, 0xE8,             // mov    rcx,[rax-0x18]
		0x0F, 0x28, 0x28,                	// movaps xmm5,[rax]
		0x0F, 0x28, 0x60, 0x10,             // movaps xmm4,[rax+0x10]
		0x0F, 0x28, 0x58, 0x20,             // movaps xmm3,[rax+0x20]
		0x0F, 0x28, 0x50, 0x30,             // movaps xmm2,[rax+0x30]
		0x0F, 0x28, 0x48, 0x40,             // movaps xmm1,[rax+0x40]
		0x0F, 0x28, 0x40, 0x50,             // movaps xmm0,[rax+0x50]
		0x48, 0x8B, 0x60, 0xF0,             // mov    rsp,[rax-0x10]
		0xC3,								// ret
		};
	};
}